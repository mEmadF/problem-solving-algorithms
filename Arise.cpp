#include <bits/stdc++.h>
using namespace std;

#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)
#define ll long long
#define vec vector
#define II <int , int>
#define LL <ll , ll>
#define IV <int , vec<int>>
#define lsort(v) sort((v).begin() , (v).end())
#define rsort(v) sort((v).rbegin() , (v).rend())
#define loop(s , n , x) for(int i = s; i < n; i += x)
#define rloop(s , n , x) for(int i = s; i >= n; i -= x)
#define printvec(v) loop(0 , v.size() , 1){cout << v[i] << " ";}
#define printmpII(m) for(auto it = m.begin(); it != m.end(); it++){cout << it->fi <<" : " <<it->sec << endl;}
#define printmpIV(m) for(auto it = m.begin(); it != m.end(); it++){cout << it->fi <<" : ";  printvec(it->sec) cout << endl;}
#define sortmapIV(m) for(auto it = m.begin(); it != m.end(); it++){lsort(it->sec);}
#define pb push_back
#define mp make_pair
#define fi first
#define sec second
#define YES cout << "YES" << endl;
#define yes cout << "yes" << endl;
#define NO cout  << "NO" << endl;
#define no cout << "no" << endl;
#define solveit solution s1;s1.solve();


bool isprime(ll n){ // O(sqrt(n))

	if(n == 1) return false;
	for(ll i = 2 ; i*i <= n ; i++)
		if(n % i == 0)
			return false;
	return true;
}


vector<bool> SieveOfEratosthenes(ll start, ll end){ // O(n log log n)
    vector<bool> ispr(end + 1, true);
    ispr[0] = ispr[1] = false; // ....

    for (ll i = 2; i * i <= start + end; i++){ // i*i because if a number 'x' is not a prime and has a factor 'y', then 'y' must be less than or equal to the square root of 'x'
// cur : minimum multiple of i in [start+1, start+n] ex : 2 * (5 / 2) + 2 = 6 (six is after start and first multiple of 2)
        ll cur = i * (start / i) + i;
        
        for (ll j = cur; j <= start + end; j += i)
            if (j != i)
                ispr[j - start] = false;
    }

    // Printing prime numbers
    // cout << "Prime numbers in the range [" << start + 1 << ", " << start + end << "] are:" << endl;
    // for (ll i = 1; i <= end; i++) {
    //     if (ispr[i]) {
    //         cout << start + i << " ";
    //     }

        
    // }
    // cout << endl;
    return ispr;
}


map<ll, ll> primeFactorization(ll n) { // O(sqrt(n) * log(n))
     map<ll, ll> factors;
    for (ll i = 2; i * i <= n; ++i) { //The loop runs while i*i is less than or equal to n. This is because any factor of n must be less than or equal to the square root of n.
        while (n % i == 0) {           //Why not sqrt(n) to avoid unnecessary float and i*i is quite faster than sqrt
            factors[i]++;
            n /= i;
        }
    }

    if (n > 1) {
        factors[n]++;
    }
    return factors;
}
/*
Prime Factorization:
n = 2^2 × 3^1 × 5^1

Counting the Powers:
The powers of the prime factors are a = 2 (for 2), b = 1 (for 3), and c = 1 (for 5).

Number of Divisors Formula:
The number of divisors (D) can be calculated using the formula:
D = (a+1) × (b+1) × (c+1) = 3 × 2 × 2 = 12

List of Divisors:
The divisors can be generated by combining the prime factors in all possible ways:

2^0 × 3^0 × 5^0 = 1
2^1 × 3^0 × 5^0 = 2
2^2 × 3^0 × 5^0 = 4
2^0 × 3^1 × 5^0 = 3
2^1 × 3^1 × 5^0 = 6
2^2 × 3^1 × 5^0 = 12
2^0 × 3^0 × 5^1 = 5
2^1 × 3^0 × 5^1 = 10
2^2 × 3^0 × 5^1 = 20
2^0 × 3^1 × 5^1 = 15
2^1 × 3^1 × 5^1 = 30
2^2 × 3^1 × 5^1 = 60

These are the 12 divisors of 60.

*/






void Tprimes(){
    ll n , x;
    cin >> n;
  while(n--){
    cin >> x;

    ll m = sqrt(x);

    if(m * m == x && isprime(m)) // you can use precomputed from sieve of Eratosthenes
        YES  
    else
        NO

  }

}
//only squares of prime numbers are T-primes




void kFactorization(ll n , ll k){

    if(k == 1){
    cout << n << endl;
    return;
    }

  if(isprime(n)){

    cout << -1 << endl; 
    return;
  }
  
  map LL m = primeFactorization(n);
  //printmpII(m);
  //mp.size() -> mp.cnt all (values)
  vec<pair<ll , ll>> v;

      ll sum = 0;
  for(auto it = m.begin(); it != m.end(); it++){ 
    v.push_back(mp(it->fi ,it->sec));
    sum += it->sec;
  }
  if(sum < k){
    cout << -1 << endl;
    return;
  }
  else{
    ll i = 0;
    while(v.size() < k){
        if(v[i].sec > 1){
            v.push_back(mp(v[i].fi , 1));
            v[i].sec--;
        }
        else{
            i++;
        }
    }
    if(k < v.size()){
    double tmp = 1;
    while(k < v.size() + 1){
        tmp *= pow(v.back().first , v.back().sec);
        v.pop_back();
    }
    v.push_back(mp(tmp , 1));

    }


}
    for(int i = 0; i < v.size(); i++){
        cout << pow(v[i].fi , v[i].sec) << " ";
    }
}



ll gcd(ll a , ll b){
    while(a % b){
        ll remainder = a % b;
        a = b;
        b = remainder;
    }
    return b;
}

ll lcm(ll a , ll b){
    return (a * b) / gcd(a , b);
}
//gcd(a, lcm(b, c)) = lcm(gcd(a, b), gcd(a, c))
//lcm(a, gcd(b, c)) = gcd(lcm(a, b), lcm(a, c)).
//GCD(a, b) * LCM(a, b) = a * b
//GCD(a, LCM(b, c)) = LCM(GCD(a, b), GCD(a, c))


set<ll> allFactors(ll num){ // O(sqrt(num))
    set<ll> factors;
    for (ll i = 1; i * i <= num; ++i) {
        if (num % i == 0) {
            factors.insert(i);
            factors.insert(num / i);
        }
    }
    return factors;
}

set<ll> commonDivisors(ll num1, ll num2){
     set<ll> factors1 = allFactors(num1);
     //set <ll> factors2;
     set <ll> common;
   // factors2 = allFactors(num2);

    for (auto x : factors1) {
        if (num2 % x == 0) {
            common.insert(x);
        }
    }

    return common;
}

ll maxGCD(ll n)
{
    return (n / 2);
}
//The GCD of N and N / 2 is N / 2 which is the maximum of all GCDs possible for any pair from 1 to N.



// for reference, O(n log n) from Harmonic Sequence
//getDivisorsnTheirSum in a from 1 to sieveSize
vector<ll> getDivisorsnTheirSum(ll sieveSize)
{
    ll C = sieveSize; // sieve size
    vector<ll> tau(C + 1); // number of divisors
    vector<ll> sig(C + 1); // sum of divisors
	for(int i=1 ; i<=C ; i++)
		for(int j=i ; j<=C ; j+=i)
			tau[j]++, sig[j]+=i;
    
    return tau;



    // for(int i = 0; i < tau.size();i++){
    //     cout << i << ": " << tau[i] << endl;
        
    // }

    // cout << endl << endl;
    // for(int i = 0; i < sig.size();i++){
    //     cout << i << ": " << sig[i] << endl;
        
    // }
}

//O(sqrt(n))
vector<pair<ll, ll>> factorize(ll n)
{
	vector< pair<ll, ll> > ret; ret.clear();
	for(ll i=2 ; i*i<=n ; i++)
	{
		if(n % i == 0)
		{
			ll cnt=0;
			while(n % i == 0) {cnt++; n/=i; }
			ret.push_back(make_pair(i, cnt));
		}
	}
	if(n != 1) ret.push_back(make_pair(n, 1));
	return ret;


}
    //	vector<pair<ll, ll>> test = factorize(n);
    //	for(pair<ll, ll> entry : test) cout << entry.first << " " << entry.second << "\n";



    // works in O(sqrt(n))
    ll n_floor_i(ll n){
    ll i, ub, ans=0;
	for(i = 1 ; i <= n ; i = ub+1){
		ub = n/(n/i); // upper bound
		cout << "From " << i << " to " << ub << " floor(n/i) = " << n/i << "\n";
        ans += (ub-i+1) * (n/i); // # numbers in the range * floor(n/i) --- // Exercise : find sum_{i=1}^n floor(n/i) in O(sqrt(n)) time
        //for(i=1, ans=0 ; i<=n ; i++) ans+=n/i; // Alternative way
	}

	    return ans;

    }

ll aX_mod_b(ll a, ll b) // ax == 1 (mod b), assumes gcd(a, b) = 1
{
	if(a==0 && b==1) return 0;
	if(a==1) return 1; // a = 1
	return b - aX_mod_b(b%a, a) * b / a;
    //Trace Example a = 7, b = 11  final output = 8 --> 8*7 % 11 = 1

    //7 11  return 11 - axb(4, 7) * 11 / 7  
            //11 - 3 * 11 / 7
            //11 - 33/7 = 11 - 4 = 8

    //axb(4, 7) returns 3
    //4 7   return 7 - axb(3, 4) * 7 / 4
    //      7 - 2 * 7 / 4 = 3


    //axb(3, 4) return 2
    //3 4   return 4 - axb(1, 3) * 4 / 3
            // 4 - 1 * 4 / 3 = 2

    //axb(1, 3) returns 1

}

pair<ll, ll> ExtendedEuclidean(ll a, ll b) // solution of ax + by = 1 with 0 <= x < b ... assume gcd(a, b) = 1 and positive integer inputs
{
	if(a==0) return make_pair(0, 1);
	if(b==0) return make_pair(1, 0);
	pair<ll, ll> prv = ExtendedEuclidean(b, a%b);
	ll x = ((prv.second % b) + b) % b; // x = y' mod b
	ll y = (1 - a * x) / b; // ax + by = 1
	return make_pair(x, y);
}
//Bézout's identity — Let a and b be integers with greatest common divisor d. Then there exist integers x and y such that ax + by = d.

pair<ll, ll> CRT(pair<ll, ll> A, pair<ll, ll> B)
{
	if(A.second == -1 || B.second == -1) return make_pair(-1, -1);
	if(A.second == 1) return B;
	if(B.second == 1) return A;
	ll g = gcd(A.second, B.second); // gcd
	ll l = A.second * (B.second / g); // lcm
	if((B.first-A.first)%g!=0) return make_pair(-1, -1); // no solution case

	ll a = A.second / g; 
	ll b = B.second / g;
	ll mul = (B.first-A.first) / g;
	mul = (mul * aX_mod_b(a%b, b)) % b; // this is now t
	ll ret = (mul * A.second + A.first); // n_1 t + a_1
	ret %= l; ret = (ret + l) % l; // take modulos
	return make_pair(ret, l);
}